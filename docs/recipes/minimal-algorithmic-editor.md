---
title: A Minimal Algorithmic Editor
chef: Kyle Booten
abstract: A recipe for building a personalized algorithmic editor that uses regular
  expressions to detect writing patterns and insert custom annotations prompting revision.
description: |
  A Minimal Algorithmic Editor is a recipe for building a personalized
  computational writing partner — simpler than a spell-checker but more flexible.
  The human writer identifies patterns in their own text that could be improved:
  vague words, repeated sentence openings, missed opportunities for specificity
  or wit. They then encode these observations as regular expressions, write
  personalized editorial annotations for each pattern, and run a script that
  automatically marks up their text with those notes.

  The recipe walks through five steps: writing a source text; identifying places
  for development; composing regular expressions to detect those patterns;
  composing annotations; and running a Perl or Python script to annotate the text.
  The annotations can be practical ("use a more specific word") or provocative
  ("implicitly contradict Adorno's critique of jazz"). A probabilistic system
  ensures the editor flags only some instances, keeping feedback surprising.

  The piece sits at the intersection of computational poetics and editorial
  practice. Rather than outsourcing judgment to a pre-trained AI, the writer must
  externalize and formalize their own aesthetic sensibilities as code. In doing
  so, they often discover things about their writing habits they had not
  consciously noticed. The code itself becomes a form of self-knowledge.
genres:
  - Human-computer collaboration
  - Machine reading
difficulty_pans: 3
yields: |
  An annotated version of a human-written text, marked up with personalized
  editorial comments generated by the writer's own regular expressions, prompting
  revision by surfacing patterns the writer has identified as worth developing.
github_link: https://github.com/kylebooten/algorithmic-editor
---

## Background

When the jagged red serpent appears underneath a misspelled word, or when Google
Mail's Autocompose suggests a way to finish your sentence, you have participated
in something akin to e-lit. The human writes. A computer program reads and gives
suggestions. The human writer may respond in turn, rejecting or accepting any
algorithmic suggestions.

This recipe is for creating another kind of algorithmic editor — one that is
simpler even than a spell-checker, but also more flexible. The general pattern:

1. The human produces some writing
2. The human observes places where their writing could be corrected, expanded, or challenged
3. The human writes code that automatically notices these infelicities
4. The code is executed, marking up the text with helpful messages
5. These messages prompt the human's revision

## Ingredients

- Computer (ideally Mac or Linux)
- Perl
- Python
- Text editor
- Terminal emulator
- A piece of human-written text (as a `.txt` file)

**Preparation time:** 30 minutes

## Method

### Step 1: Write Something

Write a short text and save it as a plain `.txt` file. Example:

> I was driving back to the shop to see if I could find a thing that could make
> me feel happy. I was listening to jazz. Then my phone rang.

### Step 2: Discover Places for Development

Read your text and identify what could be improved — not for correctness, but for
interest. Notice vague words, repeated structures, missed specificity.

- "thing" — too vague. What type of thing?
- "I was driving…" and "I was listening…" — repeated sentence openings
- "jazz" — what kind of jazz?
- "Then my phone rang." — simply boring

### Step 3: Write Regular Expressions

Encode your observations as regular expressions (regexes). Examples:

```
\bthing\b            → matches the word "thing"
\b(jazz|ragtime)\b   → matches any of these music words
Then [^,]            → matches "Then" not followed by a comma
I was.{1,1000}I was  → matches repeated "I was" sentence openings
```

### Step 4: Compose Annotations

For each regex, write the message you want to send yourself:

```
\bthing\b             → "come up with a more specific word?"
\b(jazz|ragtime)\b    → "implicitly contradict Adorno's critique of jazz"
Then [^,]             → "insert a comma, then a prepositional phrase of extreme precision"
```

### Step 5: Run the Annotator

**Simple Perl command:**

```bash
perl -pe 's/\b(jazz|ragtime)\b/$1 <~[implicitly contradict Adorno]/g' \
  my_text.txt > my_text_annotated.txt
```

**Python script (probabilistic — not every match is flagged):**

```python
import re
import random
import sys

rules = [  # regex, annotation, probability
    (r"\bjazz\b",  "<~[contradict Adorno's critique of jazz]",  0.4),
    (r"\bthing\b", "<~[use a more specific word!]",             0.9),
    (r"\bhappy\b", "<~[what even is happiness?]",               0.4),
]

def annotate_line(line):
    for pattern, note, p in rules:
        regex = re.compile(pattern, flags=re.IGNORECASE)
        def repl(match):
            return match.group(0) + " " + note if random.random() < p else match.group(0)
        line = regex.sub(repl, line)
    return line

for line in sys.stdin:
    print(annotate_line(line), end="")
```

Run it:

```bash
python my_editor.py < my_file.txt > my_file_annotated.txt
```

### Step 6: Revise

Take the editorial comments seriously — which can mean taking up the challenge,
or fighting back against them.

## Notes

Regular expressions can be used in most programming languages, making them
portable across contexts. Start simply: write one to match a word, one to match
a word from a series, and one to match a word not followed by another character.
You can get very far with just those three patterns.
